{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Criando uma Pokedex! Essa apostila mostra o desenvolvimento passo-a-passo de um aplica\u00e7\u00e3o demo de um lista de Pokemons. A fun\u00e7\u00e3o principal do aplicativo ser\u00e1 consumir a API Pok\u00e9API , que se trata de uma API sobre Pokemons destinada a fins educacionais e gratuita. O c\u00f3digo desenvolvido neste tutorial est\u00e1 dispon\u00edvel no Github . Fique a vontade para consult\u00e1-lo e se esse tutorial de ajudar, recomende aos seus colegas. Gotta Catch 'Em All ! Criando projeto no Android Studio Ao abrir o Android Studio, uma tela de boas-vindas ser\u00e1 exibida(Figura 1), clique em Start a new Android Studio Project . Figura 1 - Tela Welcome Agora na tela de cria\u00e7\u00e3o de um novo projeto(Figura 2), insira o nome da aplica\u00e7\u00e3o ( Application name ), um dom\u00ednio( Company Domain ), para exemplo coloque seu nome seguido de .com , e ao final escolha onde ficar\u00e1 a pasta do projeto( Projeto Location ), clique em Next. Figura 2 - Tela New Project Como mostrado na Figura 3, deixe apenas selecionado a op\u00e7\u00e3o Phone and Tablet , com o Minimum SDK em API 15: Android 4.0.3 (IceCreamSandwich) , ent\u00e3o clique em Next Figura 3 - Tela Target Devices Selecione a op\u00e7\u00e3o Add no activity , como mostrado(Figura 4), ent\u00e3o clique em Finish Figura 4 - Tela Add Activity Ap\u00f3s isso, a estrutura de arquivos do seu projeto vai fica assim: Figura 5 - Estrutura de arquivos Pronto, agora seu projeto est\u00e1 criado. Configurando o projeto Para construirmos estes aplicativo utilizaremos algumas ferramentas para facilitar o desenvolvimento, al\u00e9m de termos que configura-lo para realizar algumas tarefas. Como o aplicativo ir\u00e1 buscar as informa\u00e7\u00f5es na internet, temos que informar que ele far\u00e1 isso no arquivo AndroidManifest.xml . Abra o arquivo e adicione, dentro da tag manifest , o seguinte trecho de c\u00f3digo: <uses-permission android:name=\"android.permission.INTERNET\"/> C\u00f3digo 1 - Permiss\u00e3o para internet Abra o arquivo build.gradle e adicione as bibliotecas de design e recyclerview, elas oferecem suporte a dispositivos com vers\u00f5es do Android anteriores ao Android Nougat, adicione tamb\u00e9m as bibliotecas para parse de dados, GSON e a Retrofit . dependencies { compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', { exclude group: 'com.android.support', module: 'support-annotations' }) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:25.3.0' // libs de compatibilidade compile 'com.android.support:design:25.3.0' compile 'com.android.support:recyclerview-v7:25.3.0' // retrofit, gson, picasso compile 'com.google.code.gson:gson:2.7' compile 'com.squareup.retrofit2:retrofit:2.1.0' compile 'com.squareup.retrofit2:converter-gson:2.1.0' compile 'com.squareup.picasso:picasso:2.5.2' } C\u00f3digo 2 - Adicionando as depend\u00eancias Criando nossa primeira Activity Agora que j\u00e1 fizemos o setup inicial, vamos criar nossa primeira Activity e assim j\u00e1 ter alguma tela para visualizarmos no emulador/celular Expanda a estrutura de visualiza\u00e7\u00e3o dos arquivos at\u00e9 exibir o nome do pacote, na imagem de exemplo(Figura 6) \u00e9 com.jonatasleon.pokedex , ent\u00e3o clique com o bot\u00e3o direito e v\u00e1 em New -> Activity -> Empty Activity . Figura 6 - Estrutura de arquivos Como na Figura 7, lembre-se de marcar a op\u00e7\u00e3o Launcher Activity , ent\u00e3o clique em Finish Figura 7 - Nova Activity Abra o arquivo activity_main.xml ( app/src/main/res/layout/activity_main.xml ) e mude para o modo de edi\u00e7\u00e3o para o modo text, altere o componente ConstraintLayout e adicione um RecyclerView para que o arquivo fique assim: <?xml version=\"1.0\" encoding=\"utf-8\"?> <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" tools:showIn=\"@layout/activity_main\" tools:context=\"com.jonatasleon.pokedex.MainActivity\"> <android.support.v7.widget.RecyclerView android:id=\"@+id/rv_pokemons\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:scrollbars=\"vertical\" /> </RelativeLayout> C\u00f3digo 3 - Arquivo activity_main.xml Voltando para o modo Design, \u00e9 exibido uma pr\u00e9via de como ficaria o layout. Figura 8 - Pr\u00e9via do Layout Agora adicione uma nova classe, clique sobre o nome do pacote novamente, New -> Java Class , coloque o nome da classe como Pokemon e clique em OK . Figura 9 - Nova classe O Pokemon ter\u00e1, por enquanto, dois atributos, name e type . Adicione dois construtores p\u00fablicos, o primeiro sem param\u00eatros, o segundo contendo os atributos criados como param\u00eatro. Ap\u00f3s isso, adicione getters e setters para cada atributo. O c\u00f3digo final do arquivo Pokemon.java deve fica da seguinte forma: package com.jonatasleon.pokedex; public class Pokemon { private String name; private String type; public Pokemon() { } public Pokemon(String name, String type) { this.name = name; this.type = type; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getType() { return type; } public void setType(String type) { this.type = type; } } C\u00f3digo 4 - Pokemon.java Agora, crie um novo layout. Clique com o bot\u00e3o direito sobre a pasta layout ent\u00e3o clique em New > Layout Resource File ( Figura 10 ) Figura 10 - Pasta layout Ent\u00e3o coloque como nome pokemon_row e em Root Element digite RelativeLayout , aperte OK Figura 11 - Adiciona layout pokemon_row Abra o arquivo pokemon_row.xml e deixe-o assim: <?xml version=\"1.0\" encoding=\"utf-8\"?> <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:focusable=\"true\" android:paddingLeft=\"16dp\" android:paddingRight=\"16dp\" android:paddingTop=\"10dp\" android:paddingBottom=\"10dp\" android:clickable=\"true\" android:background=\"?android:attr/selectableItemBackground\" android:orientation=\"vertical\"> <TextView android:id=\"@+id/tv_name\" android:textSize=\"16sp\" android:textStyle=\"bold\" android:layout_alignParentTop=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /> <TextView android:id=\"@+id/tv_type\" android:layout_below=\"@id/tv_name\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /> </RelativeLayout> C\u00f3digo 5 - Pokemon row layout Agora crie uma class chamada PokemonAdapter , essa classe ser\u00e1 feito a ponte entre os dados e o layout exibido pela activity, abra o arquivo PokemonAdapter.java e deixo assim: package com.jonatasleon.pokedex; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import java.util.List; public class PokemonAdapter extends RecyclerView.Adapter<PokemonAdapter.PokeViewHolder> { private List<Pokemon> pokemonList; public class PokeViewHolder extends RecyclerView.ViewHolder { public TextView name, type; public PokeViewHolder(View itemView) { super(itemView); name = (TextView) itemView.findViewById(R.id.tv_name); type = (TextView) itemView.findViewById(R.id.tv_type); } } public PokemonAdapter(List<Pokemon> pokemonList) { this.pokemonList = pokemonList; } @Override public PokeViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { LayoutInflater inflater = LayoutInflater.from(parent.getContext()); View itemView = inflater.inflate(R.layout.pokemon_row, parent, false); return new PokeViewHolder(itemView); } @Override public void onBindViewHolder(PokeViewHolder holder, int position) { Pokemon pokemon = pokemonList.get(position); holder.name.setText(pokemon.getName()); holder.type.setText(pokemon.getType()); } @Override public int getItemCount() { return pokemonList.size(); } } C\u00f3digo 5 - PokemonAdapter.java Abra o arquivo MainActivity.java e deixo modifique o m\u00e9todo onCreate : @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); recyclerView = (RecyclerView) findViewById(R.id.rv_pokemons); pokemonAdapter = new PokemonAdapter(pokemonList); RecyclerView.LayoutManager layoutManager; layoutManager = new LinearLayoutManager(getApplicationContext()); recyclerView.setLayoutManager(layoutManager); recyclerView.setItemAnimator(new DefaultItemAnimator()); recyclerView.setAdapter(pokemonAdapter); } C\u00f3digo 6 - M\u00e9todo onCreate Agora o RecyclerView j\u00e1 est\u00e1 implementado, no entanto nenhuma informa\u00e7\u00e3o \u00e9 exibida, vamos criar um m\u00e9todo que adicione algum dado. Dentro da classe MainActivity crie um m\u00e9todo addData: private void addData() { Pokemon poke; poke = new Pokemon(\"Bulbasaur\", \"Grama\"); pokemonList.add(poke); poke = new Pokemon(\"Charmander\", \"Fogo\"); pokemonList.add(poke); poke = new Pokemon(\"Squirtle\", \"\u00c1gua\"); pokemonList.add(poke); pokemonAdapter.notifyDataSetChanged(); } C\u00f3digo 7 - M\u00e9todo addData O c\u00f3digo da MainActivity deve ser algo como: package com.jonatasleon.pokedex; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.support.v7.widget.DefaultItemAnimator; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { List<Pokemon> pokemonList = new ArrayList<>(); RecyclerView recyclerView; PokemonAdapter pokemonAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); recyclerView = (RecyclerView) findViewById(R.id.rv_pokemons); pokemonAdapter = new PokemonAdapter(pokemonList); RecyclerView.LayoutManager layoutManager; layoutManager = new LinearLayoutManager(this); recyclerView.setLayoutManager(layoutManager); recyclerView.setItemAnimator(new DefaultItemAnimator()); recyclerView.setAdapter(pokemonAdapter); addData(); } private void addData() { Pokemon poke; poke = new Pokemon(\"Bulbasaur\", \"Grama\"); pokemonList.add(poke); poke = new Pokemon(\"Charmander\", \"Fogo\"); pokemonList.add(poke); poke = new Pokemon(\"Squirtle\", \"\u00c1gua\"); pokemonList.add(poke); pokemonAdapter.notifyDataSetChanged(); } } C\u00f3digo 8 - MainActivity completa Ao executar o aplicativo, o resultado esperado seria uma lista com os 3 Pokemons adicionados no m\u00e9todo addData. Figura 12 - Resultado Esperado Buscando dados na Pok\u00e9API Agora vamos come\u00e7ar a trazer os dados diretamente da API Fazendo uma requisi\u00e7\u00e3o no endere\u00e7o http://pokeapi.co/api/v1/pokemon/1/ , temos os dados do Bulbasaur , de todas a informa\u00e7\u00f5es enviadas pela API, vamos utilizar o seguinte objeto como exemplo: { \"attack\": 49, \"defense\": 49, \"height\": \"7\", \"hp\": 45, \"name\": \"Bulbasaur\", \"pkdx_id\": 1, \"speed\": 45, \"sprites\": [ { \"name\": \"bulbasaur\", \"resource_uri\": \"/api/v1/sprite/1/\" }, { \"name\": \"bulbasaur\", \"resource_uri\": \"/api/v1/sprite/2/\" }, { \"name\": \"bulbasaur\", \"resource_uri\": \"/api/v1/sprite/720/\" } ], \"types\": [ { \"name\": \"poison\", \"resource_uri\": \"/api/v1/type/4/\" }, { \"name\": \"grass\", \"resource_uri\": \"/api/v1/type/12/\" } ], \"weight\": \"69\" } C\u00f3digo 9 - Objeto base Para conseguirmos manipular os dados dentro do aplicativo, temos que criar classes que representem cada conjunto de dados dentro do objeto, ent\u00e3o a partir deste objeto, antes de alterar a classe Pokemon identificamos a necessidade de criar duas novas classes, PokeType e Sprite : package com.jonatasleon.pokedex; import com.google.gson.annotations.SerializedName; public class PokeType { @SerializedName(\"name\") private String name; public PokeType(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } C\u00f3digo 10 - PokeType.java Agora crie a classe Sprite , assim: package com.jonatasleon.pokedex; import com.google.gson.annotations.SerializedName; public class Sprite { @SerializedName(\"name\") private String name; @SerializedName(\"resource_uri\") private String resourceUri; public Sprite(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getResourceUri() { return resourceUri; } public void setResourceUri(String resourceUri) { this.resourceUri = resourceUri; } } C\u00f3digo 11 - Sprite.java Utilizamos annotations para dizer onde cada atributo do objeto vindo da API ser\u00e1 atribu\u00eddo. Assim, para cada @SerializedName(String) estamos vinculando um valor da API a um atributo de nossas classes. As declara\u00e7\u00f5es dos atributos da classe Pokemon ser\u00e3o alteradas, consequentemente seus getters e setters tamb\u00e9m. Os atributos ficar\u00e3o definidos assim(em caso de d\u00favida, veja o c\u00f3digo completo aqui ): package com.jonatasleon.pokedex; import com.google.gson.annotations.SerializedName; import java.util.ArrayList; import java.util.List; public class Pokemon { @SerializedName(\"name\") private String name; @SerializedName(\"attack\") private Integer attack; @SerializedName(\"defense\") private Integer defense; @SerializedName(\"height\") private String height; @SerializedName(\"hp\") private Integer health; @SerializedName(\"pkdx_id\") private Integer pokedexId; @SerializedName(\"speed\") private Integer speed; @SerializedName(\"weight\") private String weight; @SerializedName(\"sprites\") private List<Sprite> sprites = new ArrayList<>(); @SerializedName(\"types\") private List<PokeType> pokeTypes = new ArrayList<>(); /* * O construtor e os getters e setters aqui */ } C\u00f3digo 12 - Altera\u00e7\u00f5es em Pokemon.java Neste momento, classes como MainActivity e PokemonAdapter podem estar apontando algum erro, n\u00e3o vamos nos preocupar com isso agora, isso se deve pela altera\u00e7\u00e3o que fizemos no model Pokemon. Criaremos agora nossa inst\u00e2ncia da Api: ApiClient.java package com.jonatasleon.pokedex; import retrofit2.Retrofit; import retrofit2.converter.gson.GsonConverterFactory; public class ApiClient { public static final String BASE_URL = \"http://pokeapi.co/\"; private static Retrofit retrofit = null; public static Retrofit getClient() { if(retrofit == null) { retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); } return retrofit; } } C\u00f3digo 13 - ApiClient.java Nossa ApiClient representa o cliente que far\u00e1 todas as requisi\u00e7\u00f5es na Pok\u00e9API. Agora precisamos dizer ao ApiClient , onde ele deve buscar as informa\u00e7\u00f5es, para isso, criaremos nossa interface ApiInterface . Para criar uma interface, siga os mesmos passos para criar uma classe, mas na tela de inser\u00e7\u00e3o do nome da classe, altere Class para Interface . Figura 13 - Criando interface O c\u00f3digo de ApiInterface.java ficar\u00e1 assim: package com.jonatasleon.pokedex; import retrofit2.Call; import retrofit2.http.GET; import retrofit2.http.Path; public interface ApiInterface { @GET(\"api/v1/pokemon/{id}\") Call<Pokemon> getPokemon(@Path(\"id\") int id); } C\u00f3digo 14 - ApiInterface.java Com isso estamos dizendo que ao chamar o m\u00e9todo getPokemon(int) estamos fazendo uma requisi\u00e7\u00e3o GET (ver M\u00e9todos HTTP ) no recurso pokemon/{id} , com o id que ser\u00e1 passado como par\u00e2metro. Agora vamos fazer que nossas requisi\u00e7\u00f5es apare\u00e7am como uma lista de Pokemons no RecyclerView, tamb\u00e9m, como consequ\u00eancia, vamos corrigir os erros apontados em MainActivity e PokemonAdapter . Para isso, vamos criar um novo m\u00e9todo que colocar todos os names de PokeTypes em uma \u00fanica String . Abra o arquivo Pokemon.java e adicione o m\u00e9todo pokeTypesToString : /* arquivo Pokemon.js */ public String pokeTypesToString() { String types = \"\"; for (int i = 0; i < pokeTypes.size(); i++) { if(i > 0) types += \", \"; types += pokeTypes.get(i).getName(); } return types; } C\u00f3digo 15 - M\u00e9todo pokeTypesToString Agora modifique o m\u00e9todo onBindViewHolder na classe PokemonAdapter @Override public void onBindViewHolder(PokeViewHolder holder, int position) { Pokemon pokemon = pokemonList.get(position); holder.name.setText(pokemon.getName()); holder.type.setText(pokemon.pokeTypesToString()); } C\u00f3digo 16 - M\u00e9todo onBindViewHolder Agora temos modificar nosso m\u00e9todo addData na classe MainActivity : private void addData() { ApiInterface apiService = ApiClient.getClient().create(ApiInterface.class); for(int i = 1; i <= 30; i++) { Call<Pokemon> call = apiService.getPokemon(i); call.enqueue(new Callback<Pokemon>() { @Override public void onResponse(Call<Pokemon> call, Response<Pokemon> response) { if(response.isSuccessful()) { Pokemon pokemon = response.body(); pokemons.add(pokemon); pokemonAdapter.notifyDataSetChanged(); Log.i(\"POKEMON\", \"Name: \" + pokemon.getName()); Log.i(\"POKEMON\", \"Attack: \" + pokemon.getAttack()); Log.i(\"POKEMON\", \"Defense: \" + pokemon.getDefense()); Log.i(\"POKEMON\", \"Health: \" + pokemon.getHealth()); Log.i(\"POKEMON\", \"Height: \" + pokemon.getHeight()); Log.i(\"POKEMON\", \"Weight: \" + pokemon.getWeight()); } } @Override public void onFailure(Call<Pokemon> call, Throwable t) { } }); } } C\u00f3digo 17 - M\u00e9todo addData Execute o projeto, dependendo da disponibilidade da API, os dados dos 30 primeiros Pokemons ir\u00e3o ser exibidos em nosso RecyclerView , assim Figura 14 - Pokemons API Carregando imagens Para carregar imagens no RecyclerView vamos utilizar a biblioteca Picasso . Sua depend\u00eancia j\u00e1 foi adicionada ao projeto, observe a seguinte linha no arquivo build.gradle : compile 'com.squareup.picasso:picasso:2.5.2' C\u00f3digo 18 - Picasso Como vamos buscar as imagens a partir dos dados de uma Sprite , teremos que fazer um request no recurso sprite { \"id\": 1, \"image\": \"/media/img/1383395659.12.png\", \"name\": \"Bulbasaur_blue_red\" } C\u00f3digo 19 - Resumo dos dados de um recurso sprite Assim, temos que ter uma classe que represente a resposta desta requisi\u00e7\u00e3o, criamos ent\u00e3o a classe SpriteResponse import com.google.gson.annotations.SerializedName; public class SpriteResponse { @SerializedName(\"id\") private Integer id; @SerializedName(\"image\") private String image; @SerializedName(\"name\") private String name; public SpriteResponse(Integer id, String image, String name) { this.id = id; this.image = image; this.name = name; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getImage() { return image; } public void setImage(String image) { this.image = image; } public String getName() { return name; } public void setName(String name) { this.name = name; } } C\u00f3digo 20 - Classe SpriteResponse E modificamos nossa ApiInterface , adicionando o m\u00e9todo getSprite @GET(\"{resource_uri}\") Call<SpriteResponse> getSprite(@Path(\"resource_uri\") String resourceUri); C\u00f3digo 21 - getSprite em ApiInterface Tamb\u00e9m temos que alterar o nosso layout de pokemon_row.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:focusable=\"true\" android:paddingLeft=\"16dp\" android:paddingRight=\"16dp\" android:paddingTop=\"10dp\" android:paddingBottom=\"10dp\" android:clickable=\"true\" android:background=\"?android:attr/selectableItemBackground\" android:orientation=\"vertical\"> <ImageView android:layout_width=\"64dp\" android:layout_height=\"64dp\" android:id=\"@+id/iv_pokemon\" android:layout_alignParentTop=\"true\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" /> <TextView android:id=\"@+id/tv_name\" android:textSize=\"16sp\" android:textStyle=\"bold\" android:layout_alignParentTop=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@+id/iv_pokemon\" android:layout_toEndOf=\"@+id/iv_pokemon\" /> <TextView android:id=\"@+id/tv_type\" android:layout_below=\"@id/tv_name\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@+id/iv_pokemon\" android:layout_toEndOf=\"@+id/iv_pokemon\" /> </RelativeLayout> C\u00f3digo 22 - pokemon_row.xml Agora adicionamos uma ImageView ao layout, ent\u00e3o podemos mofificar nosso PokemonAdapter e seu ViewHolder : public class PokeViewHolder extends RecyclerView.ViewHolder { public TextView name, type; public ImageView ivPokemon; public PokeViewHolder(View itemView) { super(itemView); name = (TextView) itemView.findViewById(R.id.tv_name); type = (TextView) itemView.findViewById(R.id.tv_type); ivPokemon = (ImageView) itemView.findViewById(R.id.iv_pokemon); } } C\u00f3digo 23 - Classe PokeViewHolder Agora vamos modificar o m\u00e9todo onBindViewHolder : @Override public void onBindViewHolder(final PokeViewHolder holder, int position) { Pokemon pokemon = pokemonList.get(position); holder.name.setText(pokemon.getName()); holder.type.setText(pokemon.pokeTypesToString()); ApiInterface apiService = ApiClient.getClient().create(ApiInterface.class); Sprite sprite = pokemon.getSprites().get(0); String spriteUrl = sprite.getResourceUri(); Call<SpriteResponse> call = apiService.getSprite(spriteUrl); call.enqueue(new Callback<SpriteResponse>() { @Override public void onResponse(Call<SpriteResponse> call, Response<SpriteResponse> response) { if(response.isSuccessful()){ SpriteResponse spriteResponse = response.body(); String image = \"http://pokeapi.co\" + spriteResponse.getImage(); Picasso.with(holder.ivPokemon.getContext()) .load(image) .resize(64, 64) .into(holder.ivPokemon); } } @Override public void onFailure(Call<SpriteResponse> call, Throwable t) { } }); } C\u00f3digo 24 - Refatora\u00e7\u00e3o onBindViewHolder Um detalhe importante aqui, observe a linha: String spriteUrl = sprite.getResourceUri(); Como getResourceUri() retorna algo como /api/v1/sprite/1/ e nossa url base \u00e9 http://pokeapi.co/ , isso pode gerar uma String como http://pokeapi.co//api/v1/sprite/1/ , assim gerando um erro em nossa requisi\u00e7\u00e3o, para evitar isso, vamos refatorar nosso m\u00e9todo getResourceUri na classe Sprite : /* Sprite.java */ public String getResourceUri() { return resourceUri.substring(1); } C\u00f3digo 25 - getResourceUri refatorada Tudo ocorrendo corretamente, executando o projeto, temos os seguinte resultado: Figura 15 - Resultado lista com imagens Abrindo uma nova Activity Agora vamos crar uma uma activity que mostre informa\u00e7\u00f5es mais detalhadas ao selecionarmos algum Pokemon. Crie uma nova activity chamada DetailActivity . Antes de modificarmos o layout de DetailActivity , criaremos a estrutura que realiza a transi\u00e7\u00e3o de uma activity para outra. Crie uma classe chamada RecyclerTouchListener . public class RecyclerTouchListener implements RecyclerView.OnItemTouchListener { private GestureDetector gestureDetector; private ClickListener clickListener; public interface ClickListener { void onClick(View view, int position); void onLongClick(View view, int position); } public RecyclerTouchListener(Context context, final RecyclerView recyclerView, final ClickListener clickListener) { this.clickListener = clickListener; gestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() { @Override public boolean onSingleTapUp(MotionEvent e) { return true; } @Override public void onLongPress(MotionEvent e) { View child = recyclerView.findChildViewUnder(e.getX(), e.getY()); if (child != null && clickListener != null) { clickListener.onLongClick(child, recyclerView.getChildPosition(child)); } } }); } @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) { View child = rv.findChildViewUnder(e.getX(), e.getY()); if (child != null && clickListener != null && gestureDetector.onTouchEvent(e)) { clickListener.onClick(child, rv.getChildPosition(child)); } return false; } @Override public void onTouchEvent(RecyclerView rv, MotionEvent e) { } @Override public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) { } } C\u00f3digo 26 - Classe RecyclerTouchListener Diferente do que acontece com a classe ListView \u00e9 necess\u00e1rio implementar outros meios de capturar o clique em algum item da lista de um RecyclerView . Nossa rec\u00e9m-criada RecyclerTouchListener implementa a interface RecyclerView.OnItemTouchListener , onde atrav\u00e9s dela podemos capturar o toque em algum item da lista, no entanto, para facilitarmos a utiliza\u00e7\u00e3o desta classe, o construtor da RecyclerTouchListener pede uma implementa\u00e7\u00e3o de RecyclerTouchListener.ClickListener , ficando mais simples capturarmos o clique. Agora volte para a MainActivity e abaixo da linha recyclerView.setAdapter(pokemonAdapter) , adicione o seguinte trecho que captura o clique do bot\u00e3o inicia uma nova activity. recyclerView.addOnItemTouchListener(new RecyclerTouchListener(getApplicationContext(), recyclerView, new RecyclerTouchListener.ClickListener() { @Override public void onClick(View view, int position) { Intent i = new Intent(MainActivity.this, DetailActivity.class); i.putExtra(\"ID\", pokemons.get(position).getPokedexId()); startActivity(i); } @Override public void onLongClick(View view, int position) { } })); C\u00f3digo 27 - addOnItemTouchListener Agora no arquivo DetailActivity.java , modifique o m\u00e9todo onCreate @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_detail); Intent i = getIntent(); Toast.makeText(DetailActivity.this, i.getIntExtra(\"ID\", 0) + \"\", Toast.LENGTH_SHORT).show(); } C\u00f3digo 28 - M\u00e9todo onCreate Antes de executar seu c\u00f3digo, garante que o layout activity_detail esteja da seguinte forma: <?xml version=\"1.0\" encoding=\"utf-8\"?> <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/fab_margin\" android:paddingLeft=\"@dimen/fab_margin\" android:paddingRight=\"@dimen/fab_margin\" android:paddingTop=\"@dimen/fab_margin\" tools:context=\"com.jonatasleon.pokedex.DetailActivity\"> </RelativeLayout> C\u00f3digo 29 - activity_detail limpa Agora o id do pokemon \u00e9 enviado da MainActivity para a DetailActivity . Quando o m\u00e9todo onCreate da DetailActivity for executado, ele vai recuperar o id enviado e o exibira na tela atrav\u00e9s de uma Toast exibida na tela. Agora que j\u00e1 conseguimos recuperar o id do pokemon selecionado, vamos alterar o arquivo de layout detail_activity , deixando-o assim: <?xml version=\"1.0\" encoding=\"utf-8\"?> <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/fab_margin\" android:paddingLeft=\"@dimen/fab_margin\" android:paddingRight=\"@dimen/fab_margin\" android:paddingTop=\"@dimen/fab_margin\" tools:context=\"com.jonatasleon.pokedextutorial.DetailActivity\"> <ImageView android:layout_width=\"128dp\" android:layout_height=\"128dp\" android:id=\"@+id/iv_detail_pokemon\" android:layout_alignParentTop=\"true\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_marginEnd=\"16dp\" android:layout_marginRight=\"16dp\" android:layout_marginBottom=\"16dp\"/> <TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textAppearance=\"?android:attr/textAppearanceLarge\" android:text=\"@null\" android:id=\"@+id/tv_detail_name\" android:layout_alignTop=\"@+id/iv_detail_pokemon\" android:layout_toRightOf=\"@+id/iv_detail_pokemon\" android:layout_toEndOf=\"@+id/iv_detail_pokemon\" /> <TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textAppearance=\"?android:attr/textAppearanceMedium\" android:text=\"@null\" android:id=\"@+id/tv_detail_types\" android:layout_below=\"@+id/tv_detail_name\" android:layout_toRightOf=\"@+id/iv_detail_pokemon\" android:layout_toEndOf=\"@+id/iv_detail_pokemon\" /> <LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/iv_detail_pokemon\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:orientation=\"vertical\" android:background=\"#6000\"> <TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textAppearance=\"?android:attr/textAppearanceLargeInverse\" android:text=\"@null\" android:id=\"@+id/tv_detail_attack\" android:layout_marginLeft=\"16dp\" android:layout_marginStart=\"16dp\" android:layout_marginBottom=\"8dp\"/> <TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textAppearance=\"?android:attr/textAppearanceLargeInverse\" android:text=\"@null\" android:id=\"@+id/tv_detail_defense\" android:layout_marginLeft=\"16dp\" android:layout_marginStart=\"16dp\" android:layout_marginBottom=\"8dp\" /> <TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textAppearance=\"?android:attr/textAppearanceLargeInverse\" android:text=\"@null\" android:id=\"@+id/tv_detail_speed\" android:layout_marginLeft=\"16dp\" android:layout_marginStart=\"16dp\" android:layout_marginBottom=\"8dp\"/> </LinearLayout> </RelativeLayout> C\u00f3digo 30 - detailActivity Dentro da classe DetailActivity declare os elementos criados no layout: public class DetailActivity extends AppCompatActivity { private TextView tvName, tvTypes, tvAttack, tvDefense, tvSpeed; private ImageView ivPokemon; /* restante do c\u00f3digo */ } C\u00f3digo 31 - Declara\u00e7\u00e3o dos elementos No m\u00e9todo onCreate , vincule as variv\u00e9is declaradas aos seus respectivos elementos no layout: @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_detail); tvName = (TextView) findViewById(R.id.tv_detail_name); tvTypes = (TextView) findViewById(R.id.tv_detail_types); tvAttack = (TextView) findViewById(R.id.tv_detail_attack); tvDefense = (TextView) findViewById(R.id.tv_detail_defense); tvSpeed = (TextView) findViewById(R.id.tv_detail_speed); ivPokemon = (ImageView) findViewById(R.id.iv_detail_pokemon); int id = getIntent().getIntExtra(\"ID\", 0); requestData(id); } C\u00f3digo 32 - Declara\u00e7\u00e3o dos elementos Observe as duas \u00faltimas linha de c\u00f3digo do m\u00e9todo onCreate . Agora recuperamos o id do Pokemon passamos ele como param\u00eatro para o m\u00e9todo requestData , vamos criar este m\u00e9todo agora. Ainda no arquivo DetailActivity.java , crie o m\u00e9todo para trazer os dados e tamb\u00e9m exibir uma imagem do Pokemon: private void requestData(int id) { final ApiInterface apiService = ApiClient.getClient().create(ApiInterface.class); Call<Pokemon> call = apiService.getPokemon(id); call.enqueue(new Callback<Pokemon>() { @Override public void onResponse(Call<Pokemon> call, Response<Pokemon> response) { Pokemon pokemon; if(response.isSuccessful()) { pokemon = response.body(); tvName.setText(pokemon.getName()); tvTypes.setText(pokemon.pokeTypesToString()); tvAttack.setText(pokemon.getAttack().toString()); tvDefense.setText(pokemon.getDefense().toString()); tvSpeed.setText(pokemon.getSpeed().toString()); Call<SpriteResponse> callSprite; Sprite sprite = pokemon.getSprites().get(0); callSprite = apiService.getSprite(sprite.getResourceUri()); callSprite.enqueue(new Callback<SpriteResponse>() { @Override public void onResponse(Call<SpriteResponse> call, Response<SpriteResponse> response) { SpriteResponse spriteResponse; if(response.isSuccessful()) { spriteResponse = response.body(); Picasso.with(ivPokemon.getContext()) .load(\"http://pokeapi.co\" + spriteResponse.getImage()) .resize(128,128) .into(ivPokemon); } } @Override public void onFailure(Call<SpriteResponse> call, Throwable t) { } }); } } @Override public void onFailure(Call<Pokemon> call, Throwable t) { } }); } C\u00f3digo 33 - M\u00e9todo prepareData Neste c\u00f3digo encadeamos uma chamada dentro de outra, buscando o dados do Pokemon , assim que \u00e9 recebido, fazer uma requisi\u00e7\u00e3o dos dados da Sprite e ent\u00e3o, quando recebemos a URI da imagem, utilizamos a Picasso para colocar a imagem dentro da imageView que temos no layout. O resultado pode ser algo como: Figura 16 - Resultado da activity com detalhes Cores Vamos alterar a cor padr\u00e3o do aplicativo, s\u00f3 para que combine mais com a identidade gr\u00e1fica de um \"produto\" voltado para o mundo Pokemon. Altere o arquivo colors.xml ( res > values ): <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <color name=\"colorPrimary\">#F44336</color> <color name=\"colorPrimaryDark\">#D32F2F</color> <color name=\"colorAccent\">#FFEB3B</color> </resources> C\u00f3digo 34 - Cores no arquivo colors.xml Essas cores fazem parte do estilo do Material Design . Para facilitar a gera\u00e7\u00e3o das cores, utilizei o Material Design Palette . Como resultado, nossa toolbar foi alterada. Figura 17 - Toolbar vermelha Resultado Final Nos passos que seguimos ao longo do tutorial pudemos experimentar v\u00e1rios recursos de programa\u00e7\u00e3o para Android como RecyclerView (vamos parar de usar ListView , por favor), bibliotecas de terceiros para consumir uma API e carregamento de imagens e parte da estrutura de um aplicativo, contudo ainda tem muita coisa que voc\u00ea pode fazer para adiquirir mais conhecimento, por exemplo: Exibir mais informa\u00e7\u00f5es dos Pokemons; Ordenar a ordem que os Pokemons aparecem na lista, (est\u00e3o aparecendo na ordem que s\u00e3o baixados); Melhorar o layout na exibi\u00e7\u00e3o dos detalhes; Utilizar o resource GET pokemon/ para carregar o RecyclerView como uma lista infinita (no tutorial utilizamos o resource GET pokemon/{id or name}/ para carregar a lista; e Disponibilizar isso de volta para a comunidade, assim podemos aprender todos junto. Agora aproveite seu novo APP Figura 17 - Resultado Final","title":"Criando uma Pokedex!"},{"location":"#criando-uma-pokedex","text":"Essa apostila mostra o desenvolvimento passo-a-passo de um aplica\u00e7\u00e3o demo de um lista de Pokemons. A fun\u00e7\u00e3o principal do aplicativo ser\u00e1 consumir a API Pok\u00e9API , que se trata de uma API sobre Pokemons destinada a fins educacionais e gratuita. O c\u00f3digo desenvolvido neste tutorial est\u00e1 dispon\u00edvel no Github . Fique a vontade para consult\u00e1-lo e se esse tutorial de ajudar, recomende aos seus colegas. Gotta Catch 'Em All !","title":"Criando uma Pokedex!"},{"location":"#criando-projeto-no-android-studio","text":"Ao abrir o Android Studio, uma tela de boas-vindas ser\u00e1 exibida(Figura 1), clique em Start a new Android Studio Project . Figura 1 - Tela Welcome Agora na tela de cria\u00e7\u00e3o de um novo projeto(Figura 2), insira o nome da aplica\u00e7\u00e3o ( Application name ), um dom\u00ednio( Company Domain ), para exemplo coloque seu nome seguido de .com , e ao final escolha onde ficar\u00e1 a pasta do projeto( Projeto Location ), clique em Next. Figura 2 - Tela New Project Como mostrado na Figura 3, deixe apenas selecionado a op\u00e7\u00e3o Phone and Tablet , com o Minimum SDK em API 15: Android 4.0.3 (IceCreamSandwich) , ent\u00e3o clique em Next Figura 3 - Tela Target Devices Selecione a op\u00e7\u00e3o Add no activity , como mostrado(Figura 4), ent\u00e3o clique em Finish Figura 4 - Tela Add Activity Ap\u00f3s isso, a estrutura de arquivos do seu projeto vai fica assim: Figura 5 - Estrutura de arquivos Pronto, agora seu projeto est\u00e1 criado.","title":"Criando projeto no Android Studio"},{"location":"#configurando-o-projeto","text":"Para construirmos estes aplicativo utilizaremos algumas ferramentas para facilitar o desenvolvimento, al\u00e9m de termos que configura-lo para realizar algumas tarefas. Como o aplicativo ir\u00e1 buscar as informa\u00e7\u00f5es na internet, temos que informar que ele far\u00e1 isso no arquivo AndroidManifest.xml . Abra o arquivo e adicione, dentro da tag manifest , o seguinte trecho de c\u00f3digo: <uses-permission android:name=\"android.permission.INTERNET\"/> C\u00f3digo 1 - Permiss\u00e3o para internet Abra o arquivo build.gradle e adicione as bibliotecas de design e recyclerview, elas oferecem suporte a dispositivos com vers\u00f5es do Android anteriores ao Android Nougat, adicione tamb\u00e9m as bibliotecas para parse de dados, GSON e a Retrofit . dependencies { compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', { exclude group: 'com.android.support', module: 'support-annotations' }) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:25.3.0' // libs de compatibilidade compile 'com.android.support:design:25.3.0' compile 'com.android.support:recyclerview-v7:25.3.0' // retrofit, gson, picasso compile 'com.google.code.gson:gson:2.7' compile 'com.squareup.retrofit2:retrofit:2.1.0' compile 'com.squareup.retrofit2:converter-gson:2.1.0' compile 'com.squareup.picasso:picasso:2.5.2' } C\u00f3digo 2 - Adicionando as depend\u00eancias","title":"Configurando o projeto"},{"location":"#criando-nossa-primeira-activity","text":"Agora que j\u00e1 fizemos o setup inicial, vamos criar nossa primeira Activity e assim j\u00e1 ter alguma tela para visualizarmos no emulador/celular Expanda a estrutura de visualiza\u00e7\u00e3o dos arquivos at\u00e9 exibir o nome do pacote, na imagem de exemplo(Figura 6) \u00e9 com.jonatasleon.pokedex , ent\u00e3o clique com o bot\u00e3o direito e v\u00e1 em New -> Activity -> Empty Activity . Figura 6 - Estrutura de arquivos Como na Figura 7, lembre-se de marcar a op\u00e7\u00e3o Launcher Activity , ent\u00e3o clique em Finish Figura 7 - Nova Activity Abra o arquivo activity_main.xml ( app/src/main/res/layout/activity_main.xml ) e mude para o modo de edi\u00e7\u00e3o para o modo text, altere o componente ConstraintLayout e adicione um RecyclerView para que o arquivo fique assim: <?xml version=\"1.0\" encoding=\"utf-8\"?> <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" tools:showIn=\"@layout/activity_main\" tools:context=\"com.jonatasleon.pokedex.MainActivity\"> <android.support.v7.widget.RecyclerView android:id=\"@+id/rv_pokemons\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:scrollbars=\"vertical\" /> </RelativeLayout> C\u00f3digo 3 - Arquivo activity_main.xml Voltando para o modo Design, \u00e9 exibido uma pr\u00e9via de como ficaria o layout. Figura 8 - Pr\u00e9via do Layout Agora adicione uma nova classe, clique sobre o nome do pacote novamente, New -> Java Class , coloque o nome da classe como Pokemon e clique em OK . Figura 9 - Nova classe O Pokemon ter\u00e1, por enquanto, dois atributos, name e type . Adicione dois construtores p\u00fablicos, o primeiro sem param\u00eatros, o segundo contendo os atributos criados como param\u00eatro. Ap\u00f3s isso, adicione getters e setters para cada atributo. O c\u00f3digo final do arquivo Pokemon.java deve fica da seguinte forma: package com.jonatasleon.pokedex; public class Pokemon { private String name; private String type; public Pokemon() { } public Pokemon(String name, String type) { this.name = name; this.type = type; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getType() { return type; } public void setType(String type) { this.type = type; } } C\u00f3digo 4 - Pokemon.java Agora, crie um novo layout. Clique com o bot\u00e3o direito sobre a pasta layout ent\u00e3o clique em New > Layout Resource File ( Figura 10 ) Figura 10 - Pasta layout Ent\u00e3o coloque como nome pokemon_row e em Root Element digite RelativeLayout , aperte OK Figura 11 - Adiciona layout pokemon_row Abra o arquivo pokemon_row.xml e deixe-o assim: <?xml version=\"1.0\" encoding=\"utf-8\"?> <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:focusable=\"true\" android:paddingLeft=\"16dp\" android:paddingRight=\"16dp\" android:paddingTop=\"10dp\" android:paddingBottom=\"10dp\" android:clickable=\"true\" android:background=\"?android:attr/selectableItemBackground\" android:orientation=\"vertical\"> <TextView android:id=\"@+id/tv_name\" android:textSize=\"16sp\" android:textStyle=\"bold\" android:layout_alignParentTop=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /> <TextView android:id=\"@+id/tv_type\" android:layout_below=\"@id/tv_name\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /> </RelativeLayout> C\u00f3digo 5 - Pokemon row layout Agora crie uma class chamada PokemonAdapter , essa classe ser\u00e1 feito a ponte entre os dados e o layout exibido pela activity, abra o arquivo PokemonAdapter.java e deixo assim: package com.jonatasleon.pokedex; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import java.util.List; public class PokemonAdapter extends RecyclerView.Adapter<PokemonAdapter.PokeViewHolder> { private List<Pokemon> pokemonList; public class PokeViewHolder extends RecyclerView.ViewHolder { public TextView name, type; public PokeViewHolder(View itemView) { super(itemView); name = (TextView) itemView.findViewById(R.id.tv_name); type = (TextView) itemView.findViewById(R.id.tv_type); } } public PokemonAdapter(List<Pokemon> pokemonList) { this.pokemonList = pokemonList; } @Override public PokeViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { LayoutInflater inflater = LayoutInflater.from(parent.getContext()); View itemView = inflater.inflate(R.layout.pokemon_row, parent, false); return new PokeViewHolder(itemView); } @Override public void onBindViewHolder(PokeViewHolder holder, int position) { Pokemon pokemon = pokemonList.get(position); holder.name.setText(pokemon.getName()); holder.type.setText(pokemon.getType()); } @Override public int getItemCount() { return pokemonList.size(); } } C\u00f3digo 5 - PokemonAdapter.java Abra o arquivo MainActivity.java e deixo modifique o m\u00e9todo onCreate : @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); recyclerView = (RecyclerView) findViewById(R.id.rv_pokemons); pokemonAdapter = new PokemonAdapter(pokemonList); RecyclerView.LayoutManager layoutManager; layoutManager = new LinearLayoutManager(getApplicationContext()); recyclerView.setLayoutManager(layoutManager); recyclerView.setItemAnimator(new DefaultItemAnimator()); recyclerView.setAdapter(pokemonAdapter); } C\u00f3digo 6 - M\u00e9todo onCreate Agora o RecyclerView j\u00e1 est\u00e1 implementado, no entanto nenhuma informa\u00e7\u00e3o \u00e9 exibida, vamos criar um m\u00e9todo que adicione algum dado. Dentro da classe MainActivity crie um m\u00e9todo addData: private void addData() { Pokemon poke; poke = new Pokemon(\"Bulbasaur\", \"Grama\"); pokemonList.add(poke); poke = new Pokemon(\"Charmander\", \"Fogo\"); pokemonList.add(poke); poke = new Pokemon(\"Squirtle\", \"\u00c1gua\"); pokemonList.add(poke); pokemonAdapter.notifyDataSetChanged(); } C\u00f3digo 7 - M\u00e9todo addData O c\u00f3digo da MainActivity deve ser algo como: package com.jonatasleon.pokedex; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.support.v7.widget.DefaultItemAnimator; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { List<Pokemon> pokemonList = new ArrayList<>(); RecyclerView recyclerView; PokemonAdapter pokemonAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); recyclerView = (RecyclerView) findViewById(R.id.rv_pokemons); pokemonAdapter = new PokemonAdapter(pokemonList); RecyclerView.LayoutManager layoutManager; layoutManager = new LinearLayoutManager(this); recyclerView.setLayoutManager(layoutManager); recyclerView.setItemAnimator(new DefaultItemAnimator()); recyclerView.setAdapter(pokemonAdapter); addData(); } private void addData() { Pokemon poke; poke = new Pokemon(\"Bulbasaur\", \"Grama\"); pokemonList.add(poke); poke = new Pokemon(\"Charmander\", \"Fogo\"); pokemonList.add(poke); poke = new Pokemon(\"Squirtle\", \"\u00c1gua\"); pokemonList.add(poke); pokemonAdapter.notifyDataSetChanged(); } } C\u00f3digo 8 - MainActivity completa Ao executar o aplicativo, o resultado esperado seria uma lista com os 3 Pokemons adicionados no m\u00e9todo addData. Figura 12 - Resultado Esperado","title":"Criando nossa primeira Activity"},{"location":"#buscando-dados-na-pokeapi","text":"Agora vamos come\u00e7ar a trazer os dados diretamente da API Fazendo uma requisi\u00e7\u00e3o no endere\u00e7o http://pokeapi.co/api/v1/pokemon/1/ , temos os dados do Bulbasaur , de todas a informa\u00e7\u00f5es enviadas pela API, vamos utilizar o seguinte objeto como exemplo: { \"attack\": 49, \"defense\": 49, \"height\": \"7\", \"hp\": 45, \"name\": \"Bulbasaur\", \"pkdx_id\": 1, \"speed\": 45, \"sprites\": [ { \"name\": \"bulbasaur\", \"resource_uri\": \"/api/v1/sprite/1/\" }, { \"name\": \"bulbasaur\", \"resource_uri\": \"/api/v1/sprite/2/\" }, { \"name\": \"bulbasaur\", \"resource_uri\": \"/api/v1/sprite/720/\" } ], \"types\": [ { \"name\": \"poison\", \"resource_uri\": \"/api/v1/type/4/\" }, { \"name\": \"grass\", \"resource_uri\": \"/api/v1/type/12/\" } ], \"weight\": \"69\" } C\u00f3digo 9 - Objeto base Para conseguirmos manipular os dados dentro do aplicativo, temos que criar classes que representem cada conjunto de dados dentro do objeto, ent\u00e3o a partir deste objeto, antes de alterar a classe Pokemon identificamos a necessidade de criar duas novas classes, PokeType e Sprite : package com.jonatasleon.pokedex; import com.google.gson.annotations.SerializedName; public class PokeType { @SerializedName(\"name\") private String name; public PokeType(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } C\u00f3digo 10 - PokeType.java Agora crie a classe Sprite , assim: package com.jonatasleon.pokedex; import com.google.gson.annotations.SerializedName; public class Sprite { @SerializedName(\"name\") private String name; @SerializedName(\"resource_uri\") private String resourceUri; public Sprite(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getResourceUri() { return resourceUri; } public void setResourceUri(String resourceUri) { this.resourceUri = resourceUri; } } C\u00f3digo 11 - Sprite.java Utilizamos annotations para dizer onde cada atributo do objeto vindo da API ser\u00e1 atribu\u00eddo. Assim, para cada @SerializedName(String) estamos vinculando um valor da API a um atributo de nossas classes. As declara\u00e7\u00f5es dos atributos da classe Pokemon ser\u00e3o alteradas, consequentemente seus getters e setters tamb\u00e9m. Os atributos ficar\u00e3o definidos assim(em caso de d\u00favida, veja o c\u00f3digo completo aqui ): package com.jonatasleon.pokedex; import com.google.gson.annotations.SerializedName; import java.util.ArrayList; import java.util.List; public class Pokemon { @SerializedName(\"name\") private String name; @SerializedName(\"attack\") private Integer attack; @SerializedName(\"defense\") private Integer defense; @SerializedName(\"height\") private String height; @SerializedName(\"hp\") private Integer health; @SerializedName(\"pkdx_id\") private Integer pokedexId; @SerializedName(\"speed\") private Integer speed; @SerializedName(\"weight\") private String weight; @SerializedName(\"sprites\") private List<Sprite> sprites = new ArrayList<>(); @SerializedName(\"types\") private List<PokeType> pokeTypes = new ArrayList<>(); /* * O construtor e os getters e setters aqui */ } C\u00f3digo 12 - Altera\u00e7\u00f5es em Pokemon.java Neste momento, classes como MainActivity e PokemonAdapter podem estar apontando algum erro, n\u00e3o vamos nos preocupar com isso agora, isso se deve pela altera\u00e7\u00e3o que fizemos no model Pokemon. Criaremos agora nossa inst\u00e2ncia da Api: ApiClient.java package com.jonatasleon.pokedex; import retrofit2.Retrofit; import retrofit2.converter.gson.GsonConverterFactory; public class ApiClient { public static final String BASE_URL = \"http://pokeapi.co/\"; private static Retrofit retrofit = null; public static Retrofit getClient() { if(retrofit == null) { retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); } return retrofit; } } C\u00f3digo 13 - ApiClient.java Nossa ApiClient representa o cliente que far\u00e1 todas as requisi\u00e7\u00f5es na Pok\u00e9API. Agora precisamos dizer ao ApiClient , onde ele deve buscar as informa\u00e7\u00f5es, para isso, criaremos nossa interface ApiInterface . Para criar uma interface, siga os mesmos passos para criar uma classe, mas na tela de inser\u00e7\u00e3o do nome da classe, altere Class para Interface . Figura 13 - Criando interface O c\u00f3digo de ApiInterface.java ficar\u00e1 assim: package com.jonatasleon.pokedex; import retrofit2.Call; import retrofit2.http.GET; import retrofit2.http.Path; public interface ApiInterface { @GET(\"api/v1/pokemon/{id}\") Call<Pokemon> getPokemon(@Path(\"id\") int id); } C\u00f3digo 14 - ApiInterface.java Com isso estamos dizendo que ao chamar o m\u00e9todo getPokemon(int) estamos fazendo uma requisi\u00e7\u00e3o GET (ver M\u00e9todos HTTP ) no recurso pokemon/{id} , com o id que ser\u00e1 passado como par\u00e2metro. Agora vamos fazer que nossas requisi\u00e7\u00f5es apare\u00e7am como uma lista de Pokemons no RecyclerView, tamb\u00e9m, como consequ\u00eancia, vamos corrigir os erros apontados em MainActivity e PokemonAdapter . Para isso, vamos criar um novo m\u00e9todo que colocar todos os names de PokeTypes em uma \u00fanica String . Abra o arquivo Pokemon.java e adicione o m\u00e9todo pokeTypesToString : /* arquivo Pokemon.js */ public String pokeTypesToString() { String types = \"\"; for (int i = 0; i < pokeTypes.size(); i++) { if(i > 0) types += \", \"; types += pokeTypes.get(i).getName(); } return types; } C\u00f3digo 15 - M\u00e9todo pokeTypesToString Agora modifique o m\u00e9todo onBindViewHolder na classe PokemonAdapter @Override public void onBindViewHolder(PokeViewHolder holder, int position) { Pokemon pokemon = pokemonList.get(position); holder.name.setText(pokemon.getName()); holder.type.setText(pokemon.pokeTypesToString()); } C\u00f3digo 16 - M\u00e9todo onBindViewHolder Agora temos modificar nosso m\u00e9todo addData na classe MainActivity : private void addData() { ApiInterface apiService = ApiClient.getClient().create(ApiInterface.class); for(int i = 1; i <= 30; i++) { Call<Pokemon> call = apiService.getPokemon(i); call.enqueue(new Callback<Pokemon>() { @Override public void onResponse(Call<Pokemon> call, Response<Pokemon> response) { if(response.isSuccessful()) { Pokemon pokemon = response.body(); pokemons.add(pokemon); pokemonAdapter.notifyDataSetChanged(); Log.i(\"POKEMON\", \"Name: \" + pokemon.getName()); Log.i(\"POKEMON\", \"Attack: \" + pokemon.getAttack()); Log.i(\"POKEMON\", \"Defense: \" + pokemon.getDefense()); Log.i(\"POKEMON\", \"Health: \" + pokemon.getHealth()); Log.i(\"POKEMON\", \"Height: \" + pokemon.getHeight()); Log.i(\"POKEMON\", \"Weight: \" + pokemon.getWeight()); } } @Override public void onFailure(Call<Pokemon> call, Throwable t) { } }); } } C\u00f3digo 17 - M\u00e9todo addData Execute o projeto, dependendo da disponibilidade da API, os dados dos 30 primeiros Pokemons ir\u00e3o ser exibidos em nosso RecyclerView , assim Figura 14 - Pokemons API","title":"Buscando dados na Pok\u00e9API"},{"location":"#carregando-imagens","text":"Para carregar imagens no RecyclerView vamos utilizar a biblioteca Picasso . Sua depend\u00eancia j\u00e1 foi adicionada ao projeto, observe a seguinte linha no arquivo build.gradle : compile 'com.squareup.picasso:picasso:2.5.2' C\u00f3digo 18 - Picasso Como vamos buscar as imagens a partir dos dados de uma Sprite , teremos que fazer um request no recurso sprite { \"id\": 1, \"image\": \"/media/img/1383395659.12.png\", \"name\": \"Bulbasaur_blue_red\" } C\u00f3digo 19 - Resumo dos dados de um recurso sprite Assim, temos que ter uma classe que represente a resposta desta requisi\u00e7\u00e3o, criamos ent\u00e3o a classe SpriteResponse import com.google.gson.annotations.SerializedName; public class SpriteResponse { @SerializedName(\"id\") private Integer id; @SerializedName(\"image\") private String image; @SerializedName(\"name\") private String name; public SpriteResponse(Integer id, String image, String name) { this.id = id; this.image = image; this.name = name; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getImage() { return image; } public void setImage(String image) { this.image = image; } public String getName() { return name; } public void setName(String name) { this.name = name; } } C\u00f3digo 20 - Classe SpriteResponse E modificamos nossa ApiInterface , adicionando o m\u00e9todo getSprite @GET(\"{resource_uri}\") Call<SpriteResponse> getSprite(@Path(\"resource_uri\") String resourceUri); C\u00f3digo 21 - getSprite em ApiInterface Tamb\u00e9m temos que alterar o nosso layout de pokemon_row.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:focusable=\"true\" android:paddingLeft=\"16dp\" android:paddingRight=\"16dp\" android:paddingTop=\"10dp\" android:paddingBottom=\"10dp\" android:clickable=\"true\" android:background=\"?android:attr/selectableItemBackground\" android:orientation=\"vertical\"> <ImageView android:layout_width=\"64dp\" android:layout_height=\"64dp\" android:id=\"@+id/iv_pokemon\" android:layout_alignParentTop=\"true\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" /> <TextView android:id=\"@+id/tv_name\" android:textSize=\"16sp\" android:textStyle=\"bold\" android:layout_alignParentTop=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@+id/iv_pokemon\" android:layout_toEndOf=\"@+id/iv_pokemon\" /> <TextView android:id=\"@+id/tv_type\" android:layout_below=\"@id/tv_name\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@+id/iv_pokemon\" android:layout_toEndOf=\"@+id/iv_pokemon\" /> </RelativeLayout> C\u00f3digo 22 - pokemon_row.xml Agora adicionamos uma ImageView ao layout, ent\u00e3o podemos mofificar nosso PokemonAdapter e seu ViewHolder : public class PokeViewHolder extends RecyclerView.ViewHolder { public TextView name, type; public ImageView ivPokemon; public PokeViewHolder(View itemView) { super(itemView); name = (TextView) itemView.findViewById(R.id.tv_name); type = (TextView) itemView.findViewById(R.id.tv_type); ivPokemon = (ImageView) itemView.findViewById(R.id.iv_pokemon); } } C\u00f3digo 23 - Classe PokeViewHolder Agora vamos modificar o m\u00e9todo onBindViewHolder : @Override public void onBindViewHolder(final PokeViewHolder holder, int position) { Pokemon pokemon = pokemonList.get(position); holder.name.setText(pokemon.getName()); holder.type.setText(pokemon.pokeTypesToString()); ApiInterface apiService = ApiClient.getClient().create(ApiInterface.class); Sprite sprite = pokemon.getSprites().get(0); String spriteUrl = sprite.getResourceUri(); Call<SpriteResponse> call = apiService.getSprite(spriteUrl); call.enqueue(new Callback<SpriteResponse>() { @Override public void onResponse(Call<SpriteResponse> call, Response<SpriteResponse> response) { if(response.isSuccessful()){ SpriteResponse spriteResponse = response.body(); String image = \"http://pokeapi.co\" + spriteResponse.getImage(); Picasso.with(holder.ivPokemon.getContext()) .load(image) .resize(64, 64) .into(holder.ivPokemon); } } @Override public void onFailure(Call<SpriteResponse> call, Throwable t) { } }); } C\u00f3digo 24 - Refatora\u00e7\u00e3o onBindViewHolder Um detalhe importante aqui, observe a linha: String spriteUrl = sprite.getResourceUri(); Como getResourceUri() retorna algo como /api/v1/sprite/1/ e nossa url base \u00e9 http://pokeapi.co/ , isso pode gerar uma String como http://pokeapi.co//api/v1/sprite/1/ , assim gerando um erro em nossa requisi\u00e7\u00e3o, para evitar isso, vamos refatorar nosso m\u00e9todo getResourceUri na classe Sprite : /* Sprite.java */ public String getResourceUri() { return resourceUri.substring(1); } C\u00f3digo 25 - getResourceUri refatorada Tudo ocorrendo corretamente, executando o projeto, temos os seguinte resultado: Figura 15 - Resultado lista com imagens","title":"Carregando imagens"},{"location":"#abrindo-uma-nova-activity","text":"Agora vamos crar uma uma activity que mostre informa\u00e7\u00f5es mais detalhadas ao selecionarmos algum Pokemon. Crie uma nova activity chamada DetailActivity . Antes de modificarmos o layout de DetailActivity , criaremos a estrutura que realiza a transi\u00e7\u00e3o de uma activity para outra. Crie uma classe chamada RecyclerTouchListener . public class RecyclerTouchListener implements RecyclerView.OnItemTouchListener { private GestureDetector gestureDetector; private ClickListener clickListener; public interface ClickListener { void onClick(View view, int position); void onLongClick(View view, int position); } public RecyclerTouchListener(Context context, final RecyclerView recyclerView, final ClickListener clickListener) { this.clickListener = clickListener; gestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() { @Override public boolean onSingleTapUp(MotionEvent e) { return true; } @Override public void onLongPress(MotionEvent e) { View child = recyclerView.findChildViewUnder(e.getX(), e.getY()); if (child != null && clickListener != null) { clickListener.onLongClick(child, recyclerView.getChildPosition(child)); } } }); } @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) { View child = rv.findChildViewUnder(e.getX(), e.getY()); if (child != null && clickListener != null && gestureDetector.onTouchEvent(e)) { clickListener.onClick(child, rv.getChildPosition(child)); } return false; } @Override public void onTouchEvent(RecyclerView rv, MotionEvent e) { } @Override public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) { } } C\u00f3digo 26 - Classe RecyclerTouchListener Diferente do que acontece com a classe ListView \u00e9 necess\u00e1rio implementar outros meios de capturar o clique em algum item da lista de um RecyclerView . Nossa rec\u00e9m-criada RecyclerTouchListener implementa a interface RecyclerView.OnItemTouchListener , onde atrav\u00e9s dela podemos capturar o toque em algum item da lista, no entanto, para facilitarmos a utiliza\u00e7\u00e3o desta classe, o construtor da RecyclerTouchListener pede uma implementa\u00e7\u00e3o de RecyclerTouchListener.ClickListener , ficando mais simples capturarmos o clique. Agora volte para a MainActivity e abaixo da linha recyclerView.setAdapter(pokemonAdapter) , adicione o seguinte trecho que captura o clique do bot\u00e3o inicia uma nova activity. recyclerView.addOnItemTouchListener(new RecyclerTouchListener(getApplicationContext(), recyclerView, new RecyclerTouchListener.ClickListener() { @Override public void onClick(View view, int position) { Intent i = new Intent(MainActivity.this, DetailActivity.class); i.putExtra(\"ID\", pokemons.get(position).getPokedexId()); startActivity(i); } @Override public void onLongClick(View view, int position) { } })); C\u00f3digo 27 - addOnItemTouchListener Agora no arquivo DetailActivity.java , modifique o m\u00e9todo onCreate @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_detail); Intent i = getIntent(); Toast.makeText(DetailActivity.this, i.getIntExtra(\"ID\", 0) + \"\", Toast.LENGTH_SHORT).show(); } C\u00f3digo 28 - M\u00e9todo onCreate Antes de executar seu c\u00f3digo, garante que o layout activity_detail esteja da seguinte forma: <?xml version=\"1.0\" encoding=\"utf-8\"?> <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/fab_margin\" android:paddingLeft=\"@dimen/fab_margin\" android:paddingRight=\"@dimen/fab_margin\" android:paddingTop=\"@dimen/fab_margin\" tools:context=\"com.jonatasleon.pokedex.DetailActivity\"> </RelativeLayout> C\u00f3digo 29 - activity_detail limpa Agora o id do pokemon \u00e9 enviado da MainActivity para a DetailActivity . Quando o m\u00e9todo onCreate da DetailActivity for executado, ele vai recuperar o id enviado e o exibira na tela atrav\u00e9s de uma Toast exibida na tela. Agora que j\u00e1 conseguimos recuperar o id do pokemon selecionado, vamos alterar o arquivo de layout detail_activity , deixando-o assim: <?xml version=\"1.0\" encoding=\"utf-8\"?> <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/fab_margin\" android:paddingLeft=\"@dimen/fab_margin\" android:paddingRight=\"@dimen/fab_margin\" android:paddingTop=\"@dimen/fab_margin\" tools:context=\"com.jonatasleon.pokedextutorial.DetailActivity\"> <ImageView android:layout_width=\"128dp\" android:layout_height=\"128dp\" android:id=\"@+id/iv_detail_pokemon\" android:layout_alignParentTop=\"true\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_marginEnd=\"16dp\" android:layout_marginRight=\"16dp\" android:layout_marginBottom=\"16dp\"/> <TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textAppearance=\"?android:attr/textAppearanceLarge\" android:text=\"@null\" android:id=\"@+id/tv_detail_name\" android:layout_alignTop=\"@+id/iv_detail_pokemon\" android:layout_toRightOf=\"@+id/iv_detail_pokemon\" android:layout_toEndOf=\"@+id/iv_detail_pokemon\" /> <TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textAppearance=\"?android:attr/textAppearanceMedium\" android:text=\"@null\" android:id=\"@+id/tv_detail_types\" android:layout_below=\"@+id/tv_detail_name\" android:layout_toRightOf=\"@+id/iv_detail_pokemon\" android:layout_toEndOf=\"@+id/iv_detail_pokemon\" /> <LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/iv_detail_pokemon\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:orientation=\"vertical\" android:background=\"#6000\"> <TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textAppearance=\"?android:attr/textAppearanceLargeInverse\" android:text=\"@null\" android:id=\"@+id/tv_detail_attack\" android:layout_marginLeft=\"16dp\" android:layout_marginStart=\"16dp\" android:layout_marginBottom=\"8dp\"/> <TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textAppearance=\"?android:attr/textAppearanceLargeInverse\" android:text=\"@null\" android:id=\"@+id/tv_detail_defense\" android:layout_marginLeft=\"16dp\" android:layout_marginStart=\"16dp\" android:layout_marginBottom=\"8dp\" /> <TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textAppearance=\"?android:attr/textAppearanceLargeInverse\" android:text=\"@null\" android:id=\"@+id/tv_detail_speed\" android:layout_marginLeft=\"16dp\" android:layout_marginStart=\"16dp\" android:layout_marginBottom=\"8dp\"/> </LinearLayout> </RelativeLayout> C\u00f3digo 30 - detailActivity Dentro da classe DetailActivity declare os elementos criados no layout: public class DetailActivity extends AppCompatActivity { private TextView tvName, tvTypes, tvAttack, tvDefense, tvSpeed; private ImageView ivPokemon; /* restante do c\u00f3digo */ } C\u00f3digo 31 - Declara\u00e7\u00e3o dos elementos No m\u00e9todo onCreate , vincule as variv\u00e9is declaradas aos seus respectivos elementos no layout: @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_detail); tvName = (TextView) findViewById(R.id.tv_detail_name); tvTypes = (TextView) findViewById(R.id.tv_detail_types); tvAttack = (TextView) findViewById(R.id.tv_detail_attack); tvDefense = (TextView) findViewById(R.id.tv_detail_defense); tvSpeed = (TextView) findViewById(R.id.tv_detail_speed); ivPokemon = (ImageView) findViewById(R.id.iv_detail_pokemon); int id = getIntent().getIntExtra(\"ID\", 0); requestData(id); } C\u00f3digo 32 - Declara\u00e7\u00e3o dos elementos Observe as duas \u00faltimas linha de c\u00f3digo do m\u00e9todo onCreate . Agora recuperamos o id do Pokemon passamos ele como param\u00eatro para o m\u00e9todo requestData , vamos criar este m\u00e9todo agora. Ainda no arquivo DetailActivity.java , crie o m\u00e9todo para trazer os dados e tamb\u00e9m exibir uma imagem do Pokemon: private void requestData(int id) { final ApiInterface apiService = ApiClient.getClient().create(ApiInterface.class); Call<Pokemon> call = apiService.getPokemon(id); call.enqueue(new Callback<Pokemon>() { @Override public void onResponse(Call<Pokemon> call, Response<Pokemon> response) { Pokemon pokemon; if(response.isSuccessful()) { pokemon = response.body(); tvName.setText(pokemon.getName()); tvTypes.setText(pokemon.pokeTypesToString()); tvAttack.setText(pokemon.getAttack().toString()); tvDefense.setText(pokemon.getDefense().toString()); tvSpeed.setText(pokemon.getSpeed().toString()); Call<SpriteResponse> callSprite; Sprite sprite = pokemon.getSprites().get(0); callSprite = apiService.getSprite(sprite.getResourceUri()); callSprite.enqueue(new Callback<SpriteResponse>() { @Override public void onResponse(Call<SpriteResponse> call, Response<SpriteResponse> response) { SpriteResponse spriteResponse; if(response.isSuccessful()) { spriteResponse = response.body(); Picasso.with(ivPokemon.getContext()) .load(\"http://pokeapi.co\" + spriteResponse.getImage()) .resize(128,128) .into(ivPokemon); } } @Override public void onFailure(Call<SpriteResponse> call, Throwable t) { } }); } } @Override public void onFailure(Call<Pokemon> call, Throwable t) { } }); } C\u00f3digo 33 - M\u00e9todo prepareData Neste c\u00f3digo encadeamos uma chamada dentro de outra, buscando o dados do Pokemon , assim que \u00e9 recebido, fazer uma requisi\u00e7\u00e3o dos dados da Sprite e ent\u00e3o, quando recebemos a URI da imagem, utilizamos a Picasso para colocar a imagem dentro da imageView que temos no layout. O resultado pode ser algo como: Figura 16 - Resultado da activity com detalhes","title":"Abrindo uma nova Activity"},{"location":"#cores","text":"Vamos alterar a cor padr\u00e3o do aplicativo, s\u00f3 para que combine mais com a identidade gr\u00e1fica de um \"produto\" voltado para o mundo Pokemon. Altere o arquivo colors.xml ( res > values ): <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <color name=\"colorPrimary\">#F44336</color> <color name=\"colorPrimaryDark\">#D32F2F</color> <color name=\"colorAccent\">#FFEB3B</color> </resources> C\u00f3digo 34 - Cores no arquivo colors.xml Essas cores fazem parte do estilo do Material Design . Para facilitar a gera\u00e7\u00e3o das cores, utilizei o Material Design Palette . Como resultado, nossa toolbar foi alterada. Figura 17 - Toolbar vermelha","title":"Cores"},{"location":"#resultado-final","text":"Nos passos que seguimos ao longo do tutorial pudemos experimentar v\u00e1rios recursos de programa\u00e7\u00e3o para Android como RecyclerView (vamos parar de usar ListView , por favor), bibliotecas de terceiros para consumir uma API e carregamento de imagens e parte da estrutura de um aplicativo, contudo ainda tem muita coisa que voc\u00ea pode fazer para adiquirir mais conhecimento, por exemplo: Exibir mais informa\u00e7\u00f5es dos Pokemons; Ordenar a ordem que os Pokemons aparecem na lista, (est\u00e3o aparecendo na ordem que s\u00e3o baixados); Melhorar o layout na exibi\u00e7\u00e3o dos detalhes; Utilizar o resource GET pokemon/ para carregar o RecyclerView como uma lista infinita (no tutorial utilizamos o resource GET pokemon/{id or name}/ para carregar a lista; e Disponibilizar isso de volta para a comunidade, assim podemos aprender todos junto. Agora aproveite seu novo APP Figura 17 - Resultado Final","title":"Resultado Final"}]}